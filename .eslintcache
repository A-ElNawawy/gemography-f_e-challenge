[{"D:\\gemography-f_e-challenge\\src\\index.js":"1","D:\\gemography-f_e-challenge\\src\\containers\\App.js":"2","D:\\gemography-f_e-challenge\\src\\components\\CardSidePic.js":"3","D:\\gemography-f_e-challenge\\src\\components\\Container.js":"4","D:\\gemography-f_e-challenge\\src\\includes\\functions.js":"5","D:\\gemography-f_e-challenge\\src\\components\\Message.js":"6"},{"size":230,"mtime":1608824194477,"results":"7","hashOfConfig":"8"},{"size":3029,"mtime":1610037625172,"results":"9","hashOfConfig":"8"},{"size":2064,"mtime":1609968808875,"results":"10","hashOfConfig":"8"},{"size":429,"mtime":1610037115710,"results":"11","hashOfConfig":"8"},{"size":4461,"mtime":1609966990204,"results":"12","hashOfConfig":"8"},{"size":373,"mtime":1609966435658,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1eb3ksb",{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"20"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"D:\\gemography-f_e-challenge\\src\\index.js",[],"D:\\gemography-f_e-challenge\\src\\containers\\App.js",[],"D:\\gemography-f_e-challenge\\src\\components\\CardSidePic.js",[],["28","29"],"D:\\gemography-f_e-challenge\\src\\components\\Container.js",[],"D:\\gemography-f_e-challenge\\src\\includes\\functions.js",["30"],"/*\r\n** getDays Function to Calculate Difference ( in days ) Between Today And a Given Date [ Accepts Parameters]\r\n** Parameters:\r\n** date = Date Which We Want to Calculate\r\n*/\r\nfunction getDays(date){\r\n  let today = new Date();\r\n  date = new Date(date);\r\n  const diffTime = Math.abs(today - date);\r\n  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\r\n  return diffDays;\r\n}\r\n\r\n/*\r\n** getDateOf Function to Get The Date of a certain Day [ Accepts Parameters]\r\n** Parameters:\r\n** noOfDaysBack = Number of How many Days We Want to Go Back\r\n*/\r\nfunction getDateOf(noOfDaysBack){\r\n  let date = new Date();\r\n  date.setDate(date.getDate()-noOfDaysBack);\r\n  date = GetFormattedDate(date);\r\n  return(date);\r\n}\r\n\r\n/*\r\n** GetFormattedDate Function to Format a Given Date in This Format (yyyy-mm-dd) [ Accepts Parameters]\r\n** Parameters:\r\n** date = Date to Be Formatted\r\n*/\r\nfunction GetFormattedDate(date) {\r\n  var month = date.getMonth() + 1;\r\n  var day = date.getDate();\r\n  if(day < 10){day = \"0\" + day;}\r\n  var year = date.getFullYear();\r\n  return year + \"-\" + month + \"-\" + day;\r\n}\r\n\r\n/*\r\n** getData Function to Fetch Data From github [ Accepts Parameters]\r\n** Parameters:\r\n** me = The ( This ) Keyword\r\n** date = Repos Will Be Searched in The Period Between It (date) And Today\r\n** pageNo = Page Number ( to Paginate Between Pages Came From github )\r\n** per_page = How Much Repos We Want Per Page (Max: 100)\r\n*/\r\nasync function getData(me, date, pageNo, per_page) {\r\n  me.setState({loading: true});\r\n  let api = 'https://api.github.com/search/repositories?q=created:>'\r\n  +date\r\n  +'&page='+pageNo\r\n  +'&per_page='+per_page\r\n  +'&sort=stars&order=desc';\r\n  await fetch(api)\r\n  .then(response => response.json())\r\n  .then(data => {\r\n    //Check if response has items & add them to items array\r\n    if(data.items){\r\n      if(me.state.items.length === 0){\r\n        me.setState(\r\n          (state) =>({\r\n            items: state.items.concat(data.items)\r\n          })\r\n        );\r\n      }else{\r\n        //To Prevent duplication of data\r\n        if(me.state.items[0].full_name !== data.items[0].full_name){\r\n          me.setState(\r\n            (state) =>({\r\n              items: state.items.concat(data.items)\r\n            })\r\n          );\r\n        }\r\n      }\r\n    // if we have error\r\n    }else if(data.message) {\r\n      me.setState({message: data.message});\r\n    }\r\n    me.setState({loading: false});\r\n  });\r\n}\r\n\r\n/*\r\n** loadMore Function to increment the pageNo App state and Fetch Data From github [ Accepts Parameters]\r\n** Parameters:\r\n** me = The ( This ) Keyword\r\n*/\r\nfunction loadMore(me) {\r\n  me.setState((state) => ({\r\n    pageNo: state.pageNo + 1\r\n  }));\r\n  getData(\r\n    me,\r\n    me.state.date,\r\n    me.state.pageNo,\r\n    me.state.per_page\r\n  );\r\n}\r\n\r\n/*\r\n** listenToScrolling Function is monitoring if user reach the end of repos list, if so, it calls loadMore Function but throw dampEvent Function [ Accepts Parameters]\r\n** Parameters:\r\n** me = The ( This ) Keyword\r\n*/\r\nfunction listenToScrolling(me) {\r\n  let windowInnerHeight = window.innerHeight; // user screen hight\r\n  let bodyHeight = document.body.clientHeight; // the overall body hight ( increases with more repos loading )\r\n  let scrolled = document.documentElement.scrollTop; // how much user scrolled the document\r\n  if (scrolled > bodyHeight - windowInnerHeight) { // that means that user reached the end of page\r\n    if(me.state.message == \"\") { // if we have a message, that means we have error, so don't fetch data till user refresh the page\r\n      dampEvent(me);\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\n** dampEvent Function:\r\n** if we call loadMore function directly from listenToScrolling function, we will get a massive amount of fetches which will make  an error in server\r\n** so, just we get the event for one time, we want to lock the listener till the fetch ends\r\n** and this is the dampEvent function\r\n** [ Accepts Parameters]\r\n** Parameters:\r\n** me = The ( This ) Keyword\r\n*/\r\nfunction dampEvent(me) {\r\n  if(!me.lock /* lock must be declared out of this function, and can't be a state */){\r\n    me.lock = true; // scrolling will not affect loadMore for one second\r\n    setTimeout(function () {\r\n      //===================================\r\n      loadMore(me);\r\n      //===================================\r\n      me.lock = false; // we can receive another event now\r\n    }, 1000)\r\n  }\r\n}\r\n\r\nexport {\r\n  getDays,\r\n  getData,\r\n  getDateOf,\r\n  loadMore,\r\n  listenToScrolling,\r\n  dampEvent\r\n}","D:\\gemography-f_e-challenge\\src\\components\\Message.js",[],{"ruleId":"31","replacedBy":"32"},{"ruleId":"33","replacedBy":"34"},{"ruleId":"35","severity":1,"message":"36","line":110,"column":25,"nodeType":"37","messageId":"38","endLine":110,"endColumn":27},"no-native-reassign",["39"],"no-negated-in-lhs",["40"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation"]